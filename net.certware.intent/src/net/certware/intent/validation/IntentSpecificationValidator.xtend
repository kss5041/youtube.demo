/*
 * generated by Xtext
 */
package net.certware.intent.validation

import net.certware.intent.intentSpecification.Intent
import net.certware.intent.intentSpecification.IntentSpecificationPackage
import net.certware.intent.intentSpecification.Refinement
import org.eclipse.xtext.validation.Check
import net.certware.intent.intentSpecification.Decomposition
import net.certware.intent.intentSpecification.ListItem
import net.certware.intent.intentSpecification.ModelItem

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class IntentSpecificationValidator extends AbstractIntentSpecificationValidator {

	public static val UNIQUE_INTENTS_REFINEMENT = "net.certware.intent.UniqueIntentsRefinement";
	public static val UNIQUE_DECOMPOSITION_INTENT = "net.certware.intent.UniqueDecompositionIntent";
	public static val UNIQUE_LIST_ITEM_DECOMPOSITION = "net.certware.intent.UniqueListItemDecomposition";
	public static val UNIQUE_MODEL_ITEM_DECOMPOSITION = "net.certware.intent.UniqueModelItemDecomposition";
	public static val UNIQUE_LIST_ITEM_LIST_ITEM = "net.certware.intent.UniqueListItemListItem";
	public static val UNIQUE_MODEL_ITEM_LIST_ITEM = "net.certware.intent.UniqueModelItemListItem";
	
    @Check
    def checkUniqueIntentsInRefinement(Refinement refinement) {
    	// for each intent type ensure it appears only once in a refinement
    	val visitedIntentTypeNames = <String>newHashSet()
    	
    	var intents = refinement.intents
    	var i = intents.listIterator
    	while ( i.hasNext ) {
    		var d = i.next as Intent
    		var typeName = d.getType().getTypeName()
    		if ( visitedIntentTypeNames.contains(typeName)) {
    			warning("duplicate intent type '"+typeName+"' in refinement",
    				IntentSpecificationPackage::eINSTANCE.refinement_Intents,
    				UNIQUE_INTENTS_REFINEMENT,
    				d.name
    			)
    		}
			visitedIntentTypeNames.add(typeName)
    	}
    }
    
    @Check
    def checkUniqueDecompositionInIntent(Intent intent) {
    	// for each decomposition type ensure it appears only once in an intent
    	val visitedDecompositionTypeNames = <String>newHashSet()
    	
    	var decompositions = intent.getDecompositions()
    	var i = decompositions.listIterator
    	while ( i.hasNext ) {
    		var d = i.next as Decomposition
    		var typeName = d.getType().getTypeName()
    		if ( visitedDecompositionTypeNames.contains(typeName)) {
    			warning("duplicate decomposition type '"+typeName+"' in intent",
    				IntentSpecificationPackage::eINSTANCE.intent_Decompositions,
    				UNIQUE_DECOMPOSITION_INTENT,
    				d.name
    			)
    		}
			visitedDecompositionTypeNames.add(typeName)
    	}
    }
    
    @Check
    def checkUniqueListItemInDecomposition(Decomposition decomposition) {
    	// for each list item it appears only once in a decomposition list
    	val visitedListItems = <ListItem>newHashSet()
    	
    	var items = decomposition.items
    	var i = items.listIterator
    	while ( i.hasNext ) {
    		var d = i.next
    		if ( visitedListItems.contains(d)) {
    			warning("duplicate item reference '"+d.name+"' in list",
    				IntentSpecificationPackage::eINSTANCE.decomposition_Items,
    				UNIQUE_LIST_ITEM_DECOMPOSITION,
    				d.name
    			)
    		}
			visitedListItems.add(d)
    	}
    }
    
    @Check
    def checkUniqueModelItemInDecomposition(Decomposition decomposition) {
    	// for each model item it appears only once in a decomposition list
    	val visitedModelItems = <ModelItem>newHashSet()
    	
    	var items = decomposition.models
    	var i = items.listIterator
    	while ( i.hasNext ) {
    		var d = i.next as ModelItem
    		if ( visitedModelItems.contains(d)) {
    			warning("duplicate item reference '"+d.name+"' in models",
    				IntentSpecificationPackage::eINSTANCE.decomposition_Models,
    				UNIQUE_MODEL_ITEM_DECOMPOSITION,
    				d.name
    			)
    		}
			visitedModelItems.add(d)
    	}
    }
    
    @Check
    def checkUniqueListItemInListItem(ListItem item) {
    	// for each list item it appears only once in an item list
    	val visitedListItems = <ListItem>newHashSet()
    	visitedListItems.add(item) // add self, preclude from referencing in item list
    	
    	var items = item.itemReferences
    	var i = items.listIterator
    	while ( i.hasNext ) {
    		var d = i.next as ListItem
    		if ( visitedListItems.contains(d)) {
    			warning("duplicate item reference '"+d.name+"' in items",
    				IntentSpecificationPackage::eINSTANCE.listItem_ItemReferences,
    				UNIQUE_LIST_ITEM_LIST_ITEM,
					d.name    				 
    			)
    		}
			visitedListItems.add(d)
    	}
    }
    
    @Check
    def checkUniqueModelItemInListItem(ListItem item) {
    	// for each model item it appears only once in an model list
    	val visitedModelItems = <ModelItem>newHashSet()
    	
    	var items = item.modelReferences
    	var i = items.listIterator
    	while ( i.hasNext ) {
    		var d = i.next as ModelItem
    		if ( visitedModelItems.contains(d)) {
    			warning("duplicate model reference '"+d.name+"' in models",
    				IntentSpecificationPackage::eINSTANCE.listItem_ModelReferences,
    				UNIQUE_MODEL_ITEM_LIST_ITEM,
    				d.name
    			)
    		}
			visitedModelItems.add(d)
    	}
    }
}
